close all; clear;

Nx = 10;
Ny = 10;
Lx = 1;
Ly = 1;
start = 0;

strx = 0.1;
stry = 0.1;
dx = zeros(1,Nx);
dy = zeros(1,Ny);

dx(1) = strx;
dy(1) = stry;

x_line = zeros(1,Nx+1);
y_line = zeros(1,Ny+1);
nodesx = zeros(1,Nx+2);
nodesy = zeros(1,Ny+2);

nodesx(1) = start;
nodesy(1) = start;

x_line(1) = dx(1);
y_line(1) = dx(1);

for l = 1:Nx
    dx(l+1) = dx(l) - dx(l)*strx; %substitute the minus with plus for stretching in opposite direction
    x_line(l+1) = x_line(l) + dx(l);
end 

for k = 1:Ny
    dy(k+1) = dy(k) + dy(k)*stry; %substitute the plus with minus for stretching in opposite direction
    y_line(k+1) = y_line(k) + dy(k);
 end

mx = min(x_line(:)); 
my = min(y_line(:));
rangex = max(x_line(:)) - mx;
rangey = max(y_line(:)) - my;
x_linee = (x_line - mx) / rangex;
y_linee = (y_line - my) / rangey;
range_x = Lx - start;
range_y = Ly - start;
x_lineee = (x_linee * range_x) + start;
y_lineee = (y_linee * range_y) + start;

for  g = 1:Nx
    nodesx(g+1) = (x_lineee(g) + x_lineee(g+1)) / 2;
    nodesy(g+1) = (y_lineee(g) + y_lineee(g+1)) / 2;
end

nodesx(Nx+2) = x_lineee(Nx+1);
nodesy(Nx+2) = y_lineee(Nx+1);

Nodes = cell(length(nodesx), length(nodesy));
for var1 = 1:length(nodesx)
    for var2 = 1:length(nodesy)
        Nodes{var1, var2} = [nodesx(var1), nodesy(var2)];
    end
end

%%
S = -1.5; q = -5000;
T = GaussScidelSolver(nodesx, nodesy, dx, dy, Nx, Ny, Lx, Ly, S);

function T = GaussScidelSolver(nodesx, nodesy, dx, dy, Nx, Ny, Lx, Ly, S)
    T = zeros(Nx+2, Ny+2);
    % Boundary Conditions for 1 and 3
    T(1, :) = 15;
    T(end, :) = 10;
    for i = 2:Ny+1 
        dist_btw_nodesy_up = nodesy(i+2) - nodesy(i+1);
        dist_btw_nodesy_down = nodesy(i+1) - nodesy(i);
        y = nodesy(i) - nodesy(1);

        k = 16*(y/Ly) + 16; 
        % Boundary Condition for 2
        T(i, end) = 5 - 5*(y/Ly) + 15*sin(pi*y/Ly); 
        dely = dy(i);
        for j = 2:Nx+1
            fprintf('i = %d', i);
            fprintf('j = %d', j);
            Su = S * dx(j) * dy(i);
            TW = T(i, j-1);
            TE = T(i, j+1);
            TS = T(i-1, j);
            TN = T(i+1, j);

            dist_btw_nodesx_front = nodesx(j+2) - nodesx(j+1);
            dist_btw_nodesx_back = nodesx(j+1) - nodesx(j);
            delx = dx(j);
            
            aW = k * dely / dist_btw_nodesx_back;
            aE = k * dely / dist_btw_nodesx_front;
            aS = k * delx / dist_btw_nodesy_down;
            aN = k * delx / dist_btw_nodesy_up;

            aP = aW + aE + aS + aN;
            
            % Boundary Condition for 4
            if j == 2
                T(i, 1) = T(i, 2) - (q/k) * dist_btw_nodesx_front;
            end

            TP = (aW*TW + aE*TE + aS*TS + aN*TN + Su) / aP;
            T(j, i) = TP;
        end
    end

end


